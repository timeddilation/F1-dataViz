library(grid)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
watermrk <- readPNG(source = "images/watermark.png")
watermark <- rasterGrob(watermrk, interpolate = TRUE)
rm(watermrk)
circuitRacesWithLapTimes <- function(evalCircuit_Id) {
racesWithTimes <- unique(lapTimes[, raceId])
racesForCircuit <- races[circuitId == evalCircuit_Id][raceId %in% racesWithTimes][order(year)]
return(racesForCircuit)
}
generateRaceDriverLaps <- function(raceIdEval) {
raceLaps <- merge(lapTimes[raceId == raceIdEval], drivers[, .(driverId, surname)])
raceLaps[, seconds := milliseconds / 1000]
raceLaps[, totalRaceTime := cumsum(milliseconds), by = driverId]
return(raceLaps)
}
raceLapsBoxPlotsMinMax <- function(race_Id) {
# returns min and max laps times across all laps
driverLapsNormWhiskers <- lapTimes[raceId == race_Id, .(min = boxplot.stats(milliseconds)$stats[1],
max = boxplot.stats(milliseconds)$stats[5]),
by = lap]
minTime <- min(driverLapsNormWhiskers[, min])
maxTime <- 3*60*1000 #3 minutes
minMax <- c(minTime - (minTime * 0.01), maxTime * 1.05)
return(minMax)
}
driverLapTimesToolTip <- function(pp){
for (i in 1:length(pp[["x"]][["data"]])){
if (length(pp[["x"]][["data"]][[i]][["text"]]) > 0){
#extract and format lap times
dataList <- pp[["x"]][["data"]][[i]][["text"]]
driverName <- stringr::str_extract(dataList, "factor\\(surname\\): [^<]*")
driverName <- gsub("factor(surname):", "", driverName, fixed = TRUE)
driverName <- gsub(" ", "", driverName)
lapNumber <- stringr::str_extract(dataList, "lap: [^<]*")
lapNumber <- gsub("lap:", "", lapNumber)
lapNumber <- gsub(" ", "", lapNumber)
laptimes <- stringr::str_extract(dataList, "[0-9]{1,4}\\.[0-9]{1,4}")
laptimes <- lubridate::as.period(lubridate::as.duration(as.numeric(laptimes)))
laptimes <- gsub("M ", ":", laptimes, fixed = TRUE)
laptimes <- gsub("S", "", laptimes, fixed = TRUE)
laptimes <- gsub("(:)([0-9]{1})(\\.)", "\\10\\2\\3", laptimes)
laptimes <- substring(laptimes, 1, 8)
# append 0's after decimal point so it always displays with at least 3 decimal places
for (j in 1:length(laptimes)){
if (!is.na(laptimes[j])){
decimalPlaces <- stringr::str_extract(laptimes[j], "\\..*")
if (is.na(decimalPlaces)){
laptimes[j] <- paste(laptimes[j], "000", sep = "")
} else if (nchar(decimalPlaces) == 3){
laptimes[j] <- paste(laptimes[j], "0", sep = "")
} else if (nchar(decimalPlaces) == 2){
laptimes[j] <- paste(laptimes[j], "00", sep = "")
} else if (nchar(decimalPlaces) == 1){
laptimes[j] <- paste(laptimes[j], "000", sep = "")
}
}
}
mungedList <- paste("<b>Driver:</b> ", driverName,
"<br /><b>Lap:</b> ", lapNumber,
"<br /><b>Lap Time:</b> ", laptimes,
sep = "")
# driver name label
pp[["x"]][["data"]][[i]][["text"]] <- mungedList
}
}
return(pp)
}
getTrackImage <- function(circuit_Id, transparencyVal){
# have a default image to return in case one is not found
returnImage <- watermark
if (circuit_Id %in% circuits[!is.na(imageSource), circuitId]){
img <- readPNG(source = circuits[circuitId == circuit_Id, imageSource])
img2 <- matrix(rgb(img[,,1],img[,,2],img[,,3], img[,,4] * transparencyVal), nrow=dim(img)[1])
returnImage <- rasterGrob(img2, interpolate = TRUE)
}
return(returnImage)
}
convertLapTimeStringToSeconds <- function(lapTimeString){
minutes <- as.numeric(stringr::str_extract(lapTimeString, "^[0-9]{1,2}"))
seconds <- stringr::str_extract(lapTimeString, ":[0-9]{1,2}\\.[0-9]{1,3}")
seconds <- as.double(gsub(":", "", seconds, fixed = TRUE))
totalSeconds <- (minutes * 60) + seconds
return(totalSeconds)
}
convertSecondsToDisplayTime <- function(secondsToConvert){
totalMinutes <- floor(secondsToConvert / 60)
remainingSeconds <- secondsToConvert - (totalMinutes * 60)
if (remainingSeconds < 10){
displayTime <- paste(totalMinutes, ":0", sprintf("%.3f", round(remainingSeconds,3)), sep = "")
} else {
displayTime <- paste(totalMinutes, ":", sprintf("%.3f", round(remainingSeconds,3)), sep = "")
}
return(displayTime)
}
generateCircuitWorldMap <- function(circuit_Id){
worldMap <- borders("world", colour = "gray40", fill = "gray42")
circuitMap <- ggplot(circuits[circuitId == circuit_Id]) +
worldMap +
coord_cartesian(ylim = c(-50, 90)) +
geom_point(aes(x = lng, y = lat), colour = "red3", size = 30, shape = 10, stroke = 4) +
theme(axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
panel.border = element_blank(),
panel.background = element_rect(fill = "transparent"),
plot.background = element_rect(fill = "transparent"))
trackMapLocation <- "images/tempTrackMap.png"
ggsave(plot = circuitMap, trackMapLocation, device = "png", height = 9, width = 16, bg = "transparent")
img <- readPNG(source = trackMapLocation)
returnImage <- rasterGrob(img, interpolate = TRUE)
return(returnImage)
}
secondsDisplay <- data.table(
secondsInt = seq(from = 30, to = 180, by = 5),
secondsDisp = c("00:30","","","00:45","","","01:00","","","01:15","","",
"01:30","","","01:45","","","02:00","","","02:15","","",
"02:30","","","02:45","","","03:00")
)
###########################
### Load and clean data ###
###########################
loadCircuitData <- function(){
circuits <- fread("data/circuits.csv")
names(circuits) <- c("circuitId","circuitRef","name","location","country","lat","lng","alt","url")
### fix circuit names
circuits[circuitId == 18, name := "Aut?dromo Jos? Carlos Pace"]
circuits[circuitId == 20, name := "N?rburgring"]
### attach circuit image source
if (!"imageSource" %in% names(circuits)){
circuits[, imageSource := character()]
}
circuits[circuitId == 1, imageSource := "images/tracks/Albert_Park.png"]
circuits[circuitId == 2, imageSource := "images/tracks/Sepang.png"]
circuits[circuitId == 3, imageSource := "images/tracks/Sakhir1.png"]
circuits[circuitId == 4, imageSource := "images/tracks/CircuitDeCatalunya.png"]
circuits[circuitId == 6, imageSource := "images/tracks/Monte_Carlo_Formula_1_track_map.png"]
circuits[circuitId == 7, imageSource := "images/tracks/CircuitGillesVilleneuve.png"]
circuits[circuitId == 8, imageSource := "images/tracks/Magny-Cours.png"]
circuits[circuitId == 9, imageSource := "images/tracks/SilverstoneArena2010.png"]
circuits[circuitId == 10, imageSource := "images/tracks/Hockenheimring2002.png"]
circuits[circuitId == 11, imageSource := "images/tracks/Hungaroring.png"]
circuits[circuitId == 13, imageSource := "images/tracks/Track_map_of_Spa-Francorchamps_in_Belgium.png"]
circuits[circuitId == 14, imageSource := "images/tracks/Monza2000.png"]
circuits[circuitId == 15, imageSource := "images/tracks/Singapore_street_circuit_v4.png"]
circuits[circuitId == 17, imageSource := "images/tracks/ShanghaiCircuit1.png"]
circuits[circuitId == 18, imageSource := "images/tracks/Interlagos1990.png"]
circuits[circuitId == 20, imageSource := "images/tracks/Nurburgring2002.png"]
circuits[circuitId == 21, imageSource := "images/tracks/Imola1995.png"]
circuits[circuitId == 22, imageSource := "images/tracks/SuzukaCircuit2005.png"]
circuits[circuitId == 24, imageSource := "images/tracks/Circuit_Yas-Island.png"]
circuits[circuitId == 69, imageSource := "images/tracks/CircuitOfAmericas.png"]
return(circuits)
}
loadQualifyingData <- function(){
qualifiers <- fread("data/qualifying.csv")
names(qualifiers) <- c("qualifyId","raceId","driverId","constructorId","number","position","q1","q2","q3")
### set times whose value is "\N" from data to NA (null)
qualifiers <- qualifiers[, lapply(.SD, function(x) replace(x, which(x == "\\N"), NA))]
### convert lap times to seconds
qualifiers[!is.na(q1), q1sec := convertLapTimeStringToSeconds(q1)]
qualifiers[!is.na(q2), q2sec := convertLapTimeStringToSeconds(q2)]
qualifiers[!is.na(q3), q3sec := convertLapTimeStringToSeconds(q3)]
return(qualifiers)
}
loadF1Data <- function(){
circuits <<- loadCircuitData()
drivers <<- fread("data/driver.csv")
names(drivers) <<- c("driverId","driverRef","number","code","forename","surname","dob","nationality","url")
lapTimes <<- fread("data/lap_times.csv")
names(lapTimes) <<- c("raceId","driverId","lap","position","time","milliseconds")
races <<- fread("data/races.csv")
names(races) <<- c("raceId","year","round","circuitId","name","date","time","url")
results <<- fread("data/results.csv")
names(results) <<- c("resultId","raceId","driverId","constructorId","number","grid","position","positionText","positionOrder","points","laps","time","milliseconds","fastestLap","rank","fastestLapTime","fastestLapSpeed","statusId")
pitStops <<- fread("data/pit_stops.csv")
names(pitStops) <<- c("raceId","driverId","stop","lap","time","duration","milliseconds")
statuses <<- fread("data/status.csv")
names(statuses) <<- c("statusId", "status")
qualifiers <<- loadQualifyingData()
### milliseconds displayed as seconds makes lubridate functions easier
lapTimes[, seconds := milliseconds / 1000]
### create new table for fastest laps, because some of these are missing from core data
### note: this throws warning: "In eval(jsub, SDenv, parent.frame()) : NAs introduced by coercion"
### but it's fine, it's just a warning, intended behavior here.
racesWithTimes <- unique(lapTimes[, raceId])
raceSpeeds <- results[raceId %in% racesWithTimes][, fastestLapSpeed := as.numeric(fastestLapSpeed)]
raceSpeeds <- raceSpeeds[!is.na(fastestLapSpeed), .(highestSpeed = max(fastestLapSpeed)), by = raceId]
fastestLaps <<- lapTimes[, .(milliseconds = min(milliseconds)), by = raceId]
fastestLaps[, seconds := milliseconds / 1000]
for (i in 1:nrow(fastestLaps)) {
fastestLaps[i, displayTime := convertSecondsToDisplayTime(seconds)]
}
fastestLaps[, fastestLapSpeed := as.numeric()]
for (i in raceSpeeds[, raceId]) {
speedVal <- raceSpeeds[raceId == i, highestSpeed]
fastestLaps[raceId == i, fastestLapSpeed := speedVal]
}
fastestLaps[, fastestLapSpeed := sprintf("%.3f", round(fastestLapSpeed,3))]
fastestLaps[is.na(fastestLapSpeed), fastestLapSpeed := "No Data"]
}
loadF1Data()
raceCounts <- races[raceId %in% unique(lapTimes[, raceId]), .(races = .N), by = circuitId][order(races)]
raceCounts <- merge(raceCounts, circuits[, .(circuitId, name)])
raceCounts[order(races, decreasing = TRUE)][1:20]
firstYearGrandPrixOnCircuit <- merge(unique(races[, .(name), by = circuitId]),
unique(races[, .(year = min(year)), by = name]))
merge(raceCounts, firstYearGrandPrixOnCircuit, by = "circuitId")[order(races, decreasing = TRUE)][1:20]
raceCounts[stringr::str_detect(name, ".air.")]
evalCircuit_Id <- 7 # set the circuit ID to evaluate here!!!
# only pull races that have lapTimes data
racesForCircuit <- circuitRacesWithLapTimes(evalCircuit_Id)
# pull all lap times for races, and create a "seconds" column for the lap time
allCircuitLapTimes <- lapTimes[raceId %in% racesForCircuit[, raceId]]
# remove laps for drivers that had pit stops, and the outlaps after the pit stops
allCircuitLapTimes <- merge(allCircuitLapTimes,
pitStops[, .(raceId, driverId, lap, stopDuration = duration)],
by = c("raceId", "driverId", "lap"), all.x = TRUE)
outlaps <- copy(allCircuitLapTimes[!is.na(stopDuration)])
outlaps <- outlaps[, lap := lap + 1][, .(raceId, driverId, lap, outlap = TRUE)]
allCircuitLapTimes <- merge(allCircuitLapTimes, outlaps,
by = c("raceId", "driverId", "lap"),
all.x = TRUE)
allCircuitLapTimes <- allCircuitLapTimes[is.na(stopDuration)][is.na(outlap)]
allCircuitLapTimes$stopDuration <- NULL
# limit lap times to those under 3 minutes, removes pit stop laps and exceedingly slow laps that might throw off intended resutls
anaimateLapTimesData <- allCircuitLapTimes[seconds <= 180]
anaimateLapTimesData <- merge(anaimateLapTimesData, races[, .(raceId, name, year)], by = "raceId")
# retrieve race results for all races on circuit
racesResults <- unique(races[raceId %in% unique(anaimateLapTimesData[, raceId]), .(raceId, year)])
racesResults <- merge(racesResults, fastestLaps, by = "raceId")
racesResults <- merge(racesResults, anaimateLapTimesData[, .(medianLapTime = median(seconds)), by = raceId], by = "raceId")
# setup color gradients
colorsGrab <- colorRampPalette(c("darkgreen","firebrick4"), bias = 5)
# add color gradient for fastest lap time
fastestLapColors <- racesResults[, .(raceId, seconds)][order(seconds)]
fastestLapColors[, colorGradient := colorsGrab(nrow(racesResults))]
racesResults <- merge(racesResults, fastestLapColors[, .(raceId, colorGradient)], by = "raceId")
# add color gradient for median lap time
medianLapColors <- racesResults[, .(raceId, medianLapTime)][order(medianLapTime)]
medianLapColors[, medianColorGradient := colorsGrab(nrow(racesResults))]
racesResults <- merge(racesResults, medianLapColors[, .(raceId, medianColorGradient)], by = "raceId")
rm(colorsGrab, fastestLapColors, medianLapColors, outlaps)
# add race tooltip to display fastest lap
racesResults[, raceToolTip := paste("<span style='font-size:16'>",
"**Fastest Lap: <span style = 'color:", colorGradient, "'>",
displayTime, "**</span>",
# "<br>**Fastest Lap Speed:** ", as.character(fastestLapSpeed),
"</span>",
sep = "")]
# generate the breaks for the median lap times metric
# min/max should be in increments of 5, breaks/labels should be in increments of 15
medianMin <- floor(min(racesResults[, medianLapTime]))
medianMin <- medianMin - medianMin %% 5
medianMax <- ceiling(max(racesResults[, medianLapTime]))
medianMax <- medianMax + (5 - medianMax %% 5)
medianBreaks <- secondsDisplay[secondsInt %% 15 == 0][secondsInt >= medianMin & secondsInt <= medianMax]
# boxplot stats for static reference lines
colorsGrab <- colorRampPalette(c("darkgreen","firebrick4"))
circuitBoxPlotStats <- boxplot.stats(anaimateLapTimesData[, seconds])
vlines <- data.table(metric = c("Q1", "Q2", "Median", "Q3", "Q4"),
value = circuitBoxPlotStats$stats[1:5],
metricColor = colorsGrab(5))
circuitName <- circuits[circuitId == evalCircuit_Id, name]
circuitImg <- getTrackImage(evalCircuit_Id, 0.5)
# trackWorldMap <- generateCircuitWorldMap(evalCircuit_Id)
rm(circuitBoxPlotStats, evalCircuit_Id, racesForCircuit, colorsGrab)
### define plot size
xMin <- 45
xMax <- 180
yMin <- 0
yMax <- 0.35
# density large plot
denAnim <- ggplot(anaimateLapTimesData, aes(x = seconds)) +
geom_density(data = allCircuitLapTimes[seconds <= 180], adjust = 4,
aes(x = seconds, color = "gray50", fill = "gray70", alpha = 0.5)) +
geom_density(aes(color = "red2", fill = "red2", alpha = 0.5),
adjust = 4) +
geom_vline(data = vlines, aes(xintercept = value, color = metricColor), linetype = "dashed") +
ylim(yMin,yMax) +
scale_x_time(limits = c(xMin, xMax),
breaks = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsInt],
labels = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsDisp]) +
labs(title = paste(circuitName, "{frame_time}"),
subtitle = "Lap Times Density Over Years") +
xlab("Lap Time") +
ylab("Density") +
theme_wsj() +
# legend formatting
scale_fill_identity(name = "", guide = "legend",
labels = c("All Grands Prix", "Year's Grand Prix")) +
scale_alpha_identity(element_blank()) +
scale_colour_identity(element_blank()) +
theme(legend.position = c(0.88,1), legend.direction = "vertical",
legend.background = element_blank(),
legend.text = element_text(size = 14, family = "mono"),
axis.title=element_text(size=12)) +
# watermark, track image, and fastest lap/speed
annotation_custom(circuitImg, xmin = 150, xmax = 190, ymin = 0.12, ymax = 0.3) +
annotate(geom = "text", x = 170, y = 0.015, size = 5, label = "github.com/timeddilation") +
geom_rich_text(data = racesResults[, .(year, raceToolTip)], aes(x = 150, y = 0.31, label = raceToolTip),
fill = NA, label.color = NA, hjust = 0, family = "mono") +
# gganimmate stuff
transition_time(year) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
# density large plot
denAnim <- ggplot(anaimateLapTimesData, aes(x = seconds)) +
geom_density(data = allCircuitLapTimes[seconds <= 180], adjust = 4,
aes(x = seconds, color = "gray50", fill = "gray70", alpha = 0.5)) +
geom_density(aes(color = "red2", fill = "red2", alpha = 0.5),
adjust = 4) +
geom_vline(data = vlines, aes(xintercept = value, color = metricColor), linetype = "dashed") +
ylim(yMin,yMax) +
scale_x_time(limits = c(xMin, xMax),
breaks = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsInt],
labels = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsDisp]) +
labs(title = paste(circuitName, "{frame_time}"),
subtitle = "Lap Times Density Over Years") +
xlab("Lap Time") +
ylab("Density") +
theme_wsj() +
# legend formatting
scale_fill_identity(name = "", guide = "legend",
labels = c("All Grands Prix", "Year's Grand Prix")) +
scale_alpha_identity(element_blank()) +
scale_colour_identity(element_blank()) +
theme(legend.position = c(0.88,1), legend.direction = "vertical",
legend.background = element_blank(),
legend.text = element_text(size = 14, family = "mono"),
axis.title=element_text(size=12)) +
# watermark, track image, and fastest lap/speed
annotation_custom(circuitImg, xmin = 150, xmax = 190, ymin = 0.12, ymax = 0.3) +
annotate(geom = "text", x = 170, y = 0.015, size = 5, label = "github.com/timeddilation") +
geom_richtext(data = racesResults[, .(year, raceToolTip)], aes(x = 150, y = 0.31, label = raceToolTip),
fill = NA, label.color = NA, hjust = 0, family = "mono") +
# gganimmate stuff
transition_time(year) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
# animate(denAnim, width = 960, height = 440)
# field spread (boxplot)
spreadAnim <- ggplot(anaimateLapTimesData[seconds <= 180]) +
geom_tufteboxplot(aes(y = seconds, size = 5), show.legend = FALSE, color = "gray35",
median.type = "line", hoffset = 0, voffset = 0, width = 3, whisker.type = "point") +
geom_hline(data = vlines, aes(yintercept = value, color = metricColor), linetype = "dashed") +
ylim(xMin,xMax) +
theme_wsj() +
labs(title = "Lap Times Spread") +
theme(axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
axis.title.x = element_blank(),
plot.title = element_text(size = 12),
legend.position = "none") +
scale_y_time(limits = c(xMin, xMax),
breaks = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsInt],
labels = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsDisp]) +
coord_flip() +
transition_time(year) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
# animate(spreadAnim, height = 100, width = 480)
# median lap time (line)
medianAnim <- ggplot(racesResults, aes(x = year, y = medianLapTime)) +
annotate("text", x = max(racesResults[, year]), y = median(allCircuitLapTimes[seconds <= 180, seconds]),
label = "median", color = "red", hjust = 1, vjust = -0.2) +
geom_hline(yintercept = median(allCircuitLapTimes[seconds <= 180, seconds]),
linetype = "dashed", color = "red") +
geom_line(color = "gray35") +
geom_point(aes(group = seq_along(year))) +
labs(title = "Median Lap Times") +
ylab("Lap Time (seconds)") +
theme_wsj() +
theme(plot.title = element_text(size = 12),
axis.title.x = element_blank()) +
scale_y_time(limits = c(medianMin, medianMax),
breaks = medianBreaks[, secondsInt],
labels = medianBreaks[, secondsDisp]) +
transition_reveal(year) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
# animate(medianAnim, height = 100, width = 480)
# setup some params to generate the final gif
gps <- length(unique(anaimateLapTimesData[, raceId]))
framesPerGp <- 16
totalFrames <- (gps * framesPerGp) + 15
denAnimGif <- animate(denAnim, start_pause = 5, end_pause = 10, nframes = totalFrames,
detail = 4, width = 960, height = 440)
install.packages('transformr')
install.packages('transformr')
install.packages('sf')
install.packages('transformr')
install.packages('sf')
devtools::install_github("r-spatial/sf")
install.packages('sf')
denAnimGif <- animate(denAnim, start_pause = 5, end_pause = 10, nframes = totalFrames,
detail = 4, width = 960, height = 440)
install.packages('transformr')
denAnimGif <- animate(denAnim, start_pause = 5, end_pause = 10, nframes = totalFrames,
detail = 4, width = 960, height = 440)
warnings()
animate(denAnim, width = 960, height = 440)
warnings()
evalCircuit_Id <- 7 # set the circuit ID to evaluate here!!!
# only pull races that have lapTimes data
racesForCircuit <- circuitRacesWithLapTimes(evalCircuit_Id)
# pull all lap times for races, and create a "seconds" column for the lap time
allCircuitLapTimes <- lapTimes[raceId %in% racesForCircuit[, raceId]]
# remove laps for drivers that had pit stops, and the outlaps after the pit stops
allCircuitLapTimes <- merge(allCircuitLapTimes,
pitStops[, .(raceId, driverId, lap, stopDuration = duration)],
by = c("raceId", "driverId", "lap"), all.x = TRUE)
outlaps <- copy(allCircuitLapTimes[!is.na(stopDuration)])
outlaps <- outlaps[, lap := lap + 1][, .(raceId, driverId, lap, outlap = TRUE)]
allCircuitLapTimes <- merge(allCircuitLapTimes, outlaps,
by = c("raceId", "driverId", "lap"),
all.x = TRUE)
allCircuitLapTimes <- allCircuitLapTimes[is.na(stopDuration)][is.na(outlap)]
allCircuitLapTimes$stopDuration <- NULL
# limit lap times to those under 3 minutes, removes pit stop laps and exceedingly slow laps that might throw off intended resutls
anaimateLapTimesData <- allCircuitLapTimes[seconds <= 180]
anaimateLapTimesData <- merge(anaimateLapTimesData, races[, .(raceId, name, year)], by = "raceId")
# retrieve race results for all races on circuit
racesResults <- unique(races[raceId %in% unique(anaimateLapTimesData[, raceId]), .(raceId, year)])
racesResults <- merge(racesResults, fastestLaps, by = "raceId")
racesResults <- merge(racesResults, anaimateLapTimesData[, .(medianLapTime = median(seconds)), by = raceId], by = "raceId")
# setup color gradients
colorsGrab <- colorRampPalette(c("darkgreen","firebrick4"), bias = 5)
# add color gradient for fastest lap time
fastestLapColors <- racesResults[, .(raceId, seconds)][order(seconds)]
fastestLapColors[, colorGradient := colorsGrab(nrow(racesResults))]
racesResults <- merge(racesResults, fastestLapColors[, .(raceId, colorGradient)], by = "raceId")
# add color gradient for median lap time
medianLapColors <- racesResults[, .(raceId, medianLapTime)][order(medianLapTime)]
medianLapColors[, medianColorGradient := colorsGrab(nrow(racesResults))]
racesResults <- merge(racesResults, medianLapColors[, .(raceId, medianColorGradient)], by = "raceId")
rm(colorsGrab, fastestLapColors, medianLapColors, outlaps)
# add race tooltip to display fastest lap
racesResults[, raceToolTip := paste("<span style='font-size:16px'>",
"**Fastest Lap: <span style = 'color:", colorGradient, "'>",
displayTime, "**</span>",
# "<br>**Fastest Lap Speed:** ", as.character(fastestLapSpeed),
"</span>",
sep = "")]
# generate the breaks for the median lap times metric
# min/max should be in increments of 5, breaks/labels should be in increments of 15
medianMin <- floor(min(racesResults[, medianLapTime]))
medianMin <- medianMin - medianMin %% 5
medianMax <- ceiling(max(racesResults[, medianLapTime]))
medianMax <- medianMax + (5 - medianMax %% 5)
medianBreaks <- secondsDisplay[secondsInt %% 15 == 0][secondsInt >= medianMin & secondsInt <= medianMax]
# boxplot stats for static reference lines
colorsGrab <- colorRampPalette(c("darkgreen","firebrick4"))
circuitBoxPlotStats <- boxplot.stats(anaimateLapTimesData[, seconds])
vlines <- data.table(metric = c("Q1", "Q2", "Median", "Q3", "Q4"),
value = circuitBoxPlotStats$stats[1:5],
metricColor = colorsGrab(5))
circuitName <- circuits[circuitId == evalCircuit_Id, name]
circuitImg <- getTrackImage(evalCircuit_Id, 0.5)
# trackWorldMap <- generateCircuitWorldMap(evalCircuit_Id)
rm(circuitBoxPlotStats, evalCircuit_Id, racesForCircuit, colorsGrab)
### define plot size
xMin <- 45
xMax <- 180
yMin <- 0
yMax <- 0.35
# density large plot
denAnim <- ggplot(anaimateLapTimesData, aes(x = seconds)) +
geom_density(data = allCircuitLapTimes[seconds <= 180], adjust = 4,
aes(x = seconds, color = "gray50", fill = "gray70", alpha = 0.5)) +
geom_density(aes(color = "red2", fill = "red2", alpha = 0.5),
adjust = 4) +
geom_vline(data = vlines, aes(xintercept = value, color = metricColor), linetype = "dashed") +
ylim(yMin,yMax) +
scale_x_time(limits = c(xMin, xMax),
breaks = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsInt],
labels = secondsDisplay[secondsInt %% 5 == 0 & secondsInt >= 45, secondsDisp]) +
labs(title = paste(circuitName, "{frame_time}"),
subtitle = "Lap Times Density Over Years") +
xlab("Lap Time") +
ylab("Density") +
theme_wsj() +
# legend formatting
scale_fill_identity(name = "", guide = "legend",
labels = c("All Grands Prix", "Year's Grand Prix")) +
scale_alpha_identity(element_blank()) +
scale_colour_identity(element_blank()) +
theme(legend.position = c(0.88,1), legend.direction = "vertical",
legend.background = element_blank(),
legend.text = element_text(size = 14, family = "mono"),
axis.title=element_text(size=12)) +
# watermark, track image, and fastest lap/speed
annotation_custom(circuitImg, xmin = 150, xmax = 190, ymin = 0.12, ymax = 0.3) +
annotate(geom = "text", x = 170, y = 0.015, size = 5, label = "github.com/timeddilation") +
geom_richtext(data = racesResults[, .(year, raceToolTip)], aes(x = 150, y = 0.31, label = raceToolTip),
fill = NA, label.color = NA, hjust = 0, family = "mono") +
# gganimmate stuff
transition_time(year) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
animate(denAnim, width = 960, height = 440)
install.packages('gifski')
install.packages('gifski')
animate(denAnim, width = 960, height = 440)
library(gganimate)
animate(denAnim, width = 960, height = 440)
